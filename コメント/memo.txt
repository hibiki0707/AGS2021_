Windows系の関数の中で
文字列扱う形はWとAとかである。
例えば
OutputDebugStringAと
OutputDebugStringWがある
Aはシングルバイト(マルチバイト)文字列(char)
Wはワイド文字列(wchar_t)
ワイドは「文字列リテラルなら」前回いったようにL""で
表せる。
"abcde”←シングルバイト文字列
L”abcde”←マルチバイト文字列
そもそも型が違う。で、A系がシングル、W系がマルチなので
char cstr[] = "hello world";
PutputDebugW(cstr)は型が違うので怒られる。Unicode指定をしていると
#define OutputDebugStringWと定義されてる。

数値を文字列として出力する関数は
DrawFormatStringと
printf
くらい？どちらも共通点はfloat pi = 3.141592;
printf("フォーマット文字列=%f",pi);
DrawFormatString(x,y,0xffffff,"フォーマット=%02.2f",pi);
のように関数内にフォーマット文字列を記述し「直接出力」してました。
ところがOutputDebugStringのような関数は「文字列しか受け取らない」
フォーマットしてくれない。これに対して数値を出力したければ
「渡す文字をフォーマット済みにするしかない」
それをやるのが、sprintfである。メモリ扱う都合上sprintf_sじゃないと
怒られます。SDLチェック外せばsprintf使えますが、sで説明します。

sprintf(結果を書き込みためのメモリ,”フォーマット”,数値);
sprintf_s(結果を書き込むためのメモリ,サイズ,”フォーマット”,数値);

これの第一引数にフォーマット済み文字列が書きもまれるので、それを
OutputDebugStringAに渡す。

C++の「ストリーム」について
文字列とか、データとかを流し込む、streamが「小川」とか「流れ」
を意味する。この流れが最終的にたまる場所…これが
標準出力(コマンドライン)だったり、文字列メモリだったりする。
だからストリームって言いながら、どんづまりな分けです。

実際は「ため池」みたいなところに、ちょろちょろと水が流れ込んで
行くイメージ。で、ため池が文字列バッファか、標準出力かという違い
でしかない。
coutっていうC++のコマンドは、標準出力にためるというコマンドです。

C++にはstringstreamというのがあって、これは
cout << "x=" << x << endl;
みたいなことを文字列ストリームに対して出来る型である。
出力専門なら、ostringstreamを使用する。

C言語のsprintfとかと違って、可変長文字列にも対応できる。
またC言語で可変長文字列に柔軟に対応しようとするとmallocとか使用する
事となり、解放し忘れのリスクがある。あと、確保した以上に文字列が
入ってきても危険である。

文字列ストリームの偉いのは、入ってきた分だけ拡張していくので
メモリオーバーの心配がない(ただしHW限界を超えた時は、知らない）
これ自体がオブジェクトなので、ostringstreamオブジェクトのスコープを
抜けた時点でメモリは解放される。

strigstream自体はstd::stringを内包しています。
関数str()でstringstreamからstring型を得ることができます。
string型はc_str（）関数で、文字配列としての文字列（C言語文字列）をえること
なので・・・

※文字列は想像以上にややこしい（げーむ本篇よりややこしいかのせいが）
①数値等から文字列への変換
②マルチバイト文字↔ワイド文字
③文字コード＆文字セット
④フォント回り
⑤メモリ回り
⑥改行回り

出力系の文字列関数を作る際の注意点…
引数がchar*とかwchar_t*の場合は、必ずconstを頭につける。
役割が「出力のみ」なので、他の余計なことをさせないように・・・です。

引数がstringとかwstringの場合は、const型＆としましょう。
なんでかというと、「値渡し」の場合
①値渡し□：□値のコピー
②参照渡し：参照のコピー（アドレスのコピー（4bvte or 8bvte))

値のコピーが曲者で、渡すものが構造体等の時、例えば構造体の
サイズが32byteだとすると、32バイトのメモリコピーが発生する。

引数として渡すときはメモリコピーだけじゃ済まなくて
①関数に入る瞬間に受け取る側のメモリ確保
②メモリコピーが発生（アドレスA→アドレスBへのコピー）

関数終了時に
③①で確保したメモリの解放

①～③は当然ながら、デカければでかいほど、コストがかかります。

std::vectorは引数の場合はどうなるか？

vectorがサイズと、先頭ポインタを持って、内部的に
mallocだのnewだので、配列文確保している。
で、その配列を内部に持った構造体…みたいなもの。

C++の仕様として、
vector<int> a(100);
としておいて
vector<int> b=a; // コピーコンストラクタ
vector<int> c;
c=a; // 代入

とした場合、感覚としては、代入が済んだら
bとa
は独立してほしい→代入後にaを変更しても
bに影響が出ないようにしたい。
つまり、代入の時点でないが起きてるのかというと
まず、aのサイズを調べます。で、b用にそのサイズで
メモリを確保します。b内部のポインタが確保したメモリを
指し示します。
memcpy等で、a内部が指し示しているメモリからb内部が
指し示しているメモリにコピーされます。

std::stringって、実はstd::vectorの変形に過ぎない
→内部的に同じ。で、string用に便利な巻子が
追加されてる「だけ」なので、
std::string≒std::vector<char>

なので、
void Func(std::string str);
って書くのはちょっと…引数っていうのは
関数のローカル変数に、渡された値を「コピー」する。

なので、stringをそのまま渡すと、先ほど言ったような
コピー処理が走ってしまう。コピーが必要な場面だったら
それでいいけど、「ただ出力に出すためだけ」だったら
コピーの必要はない。

このような場合にはconst std::string& strのように
渡します。

std::string≒std::vector<char>
std::wstring≒vector<wchar_t>

ストリームがややこしいパターン
もし、ostringsreamに対して、printf時の%02dのように0埋め揃えをしたい
場合などは、「マニピュレータ」というものを使用する。
①#include<iomanip>をインクルード
②setw（数値）で、フォーマットの幅を示します。↑の例ならsetw(2)とします。
③setfill(文字）で、埋めたい文字を指定します。↑の例ならsetfill('0')とします。
pathOss << std::setw(2) << std::setfill('0');
これを書くと、次にpathOssに入ってくる情報はすべてこのフォーマットになります。
使ったらそのフォーマットは解除されます。
なお、ついでに、16進にしたい場合はstd::hexを使用する。　

場合によっては、マルチバイト文字と、ワイド文字を相互変換させたい
事があります。

例えばＭＭＤのモデル（ＰＭＤ,ＰＭＸ）の中のデータには、テクスチャのパス等を
教えてくれる文字列が埋め込まれてたりします。

で、ＰＭＤの文字列は「マルチバイト文字」
ＰＭＸの文字列は「Unicode文字」（ワイド）
です。同じ作者がつくっのになぜ・・・

とはいえ、こういうで0田があるのは事実なので、相互変換が必要。
Windowsの関数であるMultiByteToWideCharとかWideCharToMultiByte
関数を使う。一時期はC++11～C++14くらいまでの草案としては
この辺の関数もC++標準になろうとしてた・・・ところがC++17になるころには
ぽしゃった・・・それくらい文字列の扱いはややこしいのである。